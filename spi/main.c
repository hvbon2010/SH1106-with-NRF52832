/**
 * Copyright (c) 2015 - 2018, Nordic Semiconductor ASA
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form, except as embedded into a Nordic
 *    Semiconductor ASA integrated circuit in a product or a software update for
 *    such product, must reproduce the above copyright notice, this list of
 *    conditions and the following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * 4. This software, with or without modification, must only be used with a
 *    Nordic Semiconductor ASA integrated circuit.
 *
 * 5. Any software provided in binary form under this license must not be reverse
 *    engineered, decompiled, modified and/or disassembled.
 *
 * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
#include "nrf_drv_spi.h"
#include "app_util_platform.h"
#include "nrf_gpio.h"
#include "nrf_delay.h"
#include "boards.h"
#include "app_error.h"
#include <string.h>
#include "nrf_log.h"
#include "nrf_log_ctrl.h"
#include "nrf_log_default_backends.h"

#define SH1106_CLK   31 // Clock Pin
#define SH1106_MOSI  30 // MOSI Pin
#define SH1106_RES   29 // Reset Pin
#define SH1106_DC    28 // Data/Command Select Pin 
#define SH1106_CS    4 // Chip select

/* User Define */
#define SH1106_128_64

#if defined SH1106_128_64 && defined SH1106_128_32
  #error "Only one SH1106 display can be specified at once in SH1106.h"
#endif
#if !defined SH1106_128_64 && !defined SH1106_128_32 && !defined SH1106_96_16
  #error "At least one SH1106 display must be specified in SH1106.h"
#endif

#if defined SH1106_128_64
  #define SH1106_LCDWIDTH                  128
  #define SH1106_LCDHEIGHT                 64
#endif
#if defined SH1106_128_32
  #define SH1106_LCDWIDTH                  128
  #define SH1106_LCDHEIGHT                 32
#endif
#if defined SH1106_96_16
  #define SH1106_LCDWIDTH                  96
  #define SH1106_LCDHEIGHT                 16
#endif

#define SH1106_SETCONTRAST                 0x81
#define SH1106_DISPLAYALLON_RESUME         0xA4
#define SH1106_DISPLAYALLON                0xA5
#define SH1106_NORMALDISPLAY               0xA6
#define SH1106_INVERTDISPLAY               0xA7
#define SH1106_DISPLAYOFF                  0xAE
#define SH1106_DISPLAYON                   0xAF

#define SH1106_SETDISPLAYOFFSET            0xD3
#define SH1106_SETCOMPINS                  0xDA

#define SH1106_SETVCOMDETECT               0xDB

#define SH1106_SETDISPLAYCLOCKDIV          0xD5
#define SH1106_SETPRECHARGE                0xD9

#define SH1106_SETMULTIPLEX                0xA8

#define SH1106_SETLOWCOLUMN                0x00
#define SH1106_SETHIGHCOLUMN               0x10

#define SH1106_SETSTARTLINE                0x40

#define SH1106_MEMORYMODE                  0x20
#define SH1106_COLUMNADDR                  0x21
#define SH1106_PAGEADDR                    0x22

#define SH1106_COMSCANINC                  0xC0
#define SH1106_COMSCANDEC                  0xC8

#define SH1106_SEGREMAP                    0xA0

#define SH1106_CHARGEPUMP                  0x8D

#define SH1106_EXTERNALVCC                 0x1
#define SH1106_SWITCHCAPVCC                0x2

// Scrolling #defines
#define SH1106_ACTIVATE_SCROLL             0x2F
#define SH1106_DEACTIVATE_SCROLL           0x2E
#define SH1106_SET_VERTICAL_SCROLL_AREA    0xA3
#define SH1106_RIGHT_HORIZONTAL_SCROLL     0x26
#define SH1106_LEFT_HORIZONTAL_SCROLL      0x27
#define SH1106_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL 0x29
#define SH1106_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL  0x2A

#define SET_SH1106_RES         nrf_gpio_pin_set(SH1106_RES)
#define CLR_SH1106_RES         nrf_gpio_pin_clear(SH1106_RES)

#define SET_SH1106_DC          nrf_gpio_pin_set(SH1106_DC)
#define CLR_SH1106_DC          nrf_gpio_pin_clear(SH1106_DC)

#define SET_SH1106_CS          nrf_gpio_pin_set(SH1106_CS)
#define CLR_SH1106_CS          nrf_gpio_pin_clear(SH1106_CS)

#define SPI_INSTANCE  1 /**< SPI instance index. */
static const nrf_drv_spi_t spi = NRF_DRV_SPI_INSTANCE(SPI_INSTANCE);  /**< SPI instance. */
static volatile bool spi_xfer_done;  /**< Flag used to indicate that SPI instance completed the transfer. */

#define TEST_STRING "Nordic"
static uint8_t       m_tx_buf[] = TEST_STRING;           /**< TX buffer. */
static uint8_t       m_rx_buf[sizeof(TEST_STRING) + 1];    /**< RX buffer. */
static const uint8_t m_length = sizeof(m_tx_buf);        /**< Transfer length. */

static uint8_t buffer[SH1106_LCDHEIGHT * SH1106_LCDWIDTH / 8] = { 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
#if (SH1106_LCDHEIGHT * SH1106_LCDWIDTH > 96*16)
0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#if (SH1106_LCDHEIGHT == 64)
0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
#endif
};

/**
 * @brief SPI user event handler.
 * @param event
 */
void spi_event_handler(nrf_drv_spi_evt_t const * p_event,
                       void *                    p_context)
{
    spi_xfer_done = true;
    NRF_LOG_INFO("Transfer completed.");
    if (m_rx_buf[0] != 0)
    {
        NRF_LOG_INFO(" Received:");
        NRF_LOG_HEXDUMP_INFO(m_rx_buf, strlen((const char *)m_rx_buf));
    }
	//NRF_LOG_FLUSH();
}

void writeSPI(uint8_t *pData, uint8_t len)
{
  spi_xfer_done = false;
  APP_ERROR_CHECK(nrf_drv_spi_transfer(&spi, pData, len, NULL, NULL));

  while (!spi_xfer_done)
  {
      __WFE();
  }
}

void SH1106writeCommand(uint8_t data)
{ 
	SET_SH1106_CS;
	CLR_SH1106_DC;
	CLR_SH1106_CS;
	writeSPI(&data, 1);
	SET_SH1106_CS;
}

void display(void) 
{
    SH1106writeCommand(SH1106_SETLOWCOLUMN | 0x0);  // low col = 0
    SH1106writeCommand(SH1106_SETHIGHCOLUMN | 0x0);  // hi col = 0
    SH1106writeCommand(SH1106_SETSTARTLINE | 0x0); // line #0
	
    //height >>= 3;
    //width >>= 3;
	uint8_t height=64;
	uint8_t width=132; 
	uint8_t m_row = 0;
	uint8_t m_col = 2;
	
	
	height >>= 3;
	width >>= 3;
	//Serial.println(width);
	
	int p = 0;
	
	uint8_t i, j, k =0;
	
			
	for ( i = 0; i < height; i++) 
	{
		// send a bunch of data in one xmission
	    SH1106writeCommand(0xB0 + i + m_row);//set page address
	    SH1106writeCommand(m_col & 0xf);//set lower column address
	    SH1106writeCommand(0x10 | (m_col >> 4));//set higher column address
		
	    for( j = 0; j < 8; j++)
	    {        
			// SPI
			SET_SH1106_CS;
			SET_SH1106_DC;
			CLR_SH1106_CS;
			
	        for ( k = 0; k < width; k++, p++) 
	        {
				writeSPI(buffer + p, 1);
	        }
	        SET_SH1106_CS;
	    }
	}
}

int main(void)
{
	uint8_t vccState = SH1106_EXTERNALVCC;
    bsp_board_init(BSP_INIT_LEDS);

    APP_ERROR_CHECK(NRF_LOG_INIT(NULL));
    NRF_LOG_DEFAULT_BACKENDS_INIT();

    nrf_drv_spi_config_t spi_config = NRF_DRV_SPI_DEFAULT_CONFIG;
    spi_config.ss_pin   = SH1106_CS;
    spi_config.miso_pin = NRF_DRV_SPI_PIN_NOT_USED;
    spi_config.mosi_pin = SH1106_MOSI;
    spi_config.sck_pin  = SH1106_CLK;
	spi_config.mode		= NRF_DRV_SPI_MODE_3;
	spi_config.bit_order = NRF_DRV_SPI_BIT_ORDER_MSB_FIRST;
	spi_config.frequency = NRF_DRV_SPI_FREQ_2M;
    APP_ERROR_CHECK(nrf_drv_spi_init(&spi, &spi_config, spi_event_handler, NULL));

    NRF_LOG_INFO("SPI example started.");
	nrf_gpio_cfg_output(SH1106_DC);
	nrf_gpio_cfg_output(SH1106_RES);
	CLR_SH1106_CS;

	// reset SH1106
	SET_SH1106_RES;
	nrf_delay_us(100);
	CLR_SH1106_RES;
	nrf_delay_us(100);
	SET_SH1106_RES;
	nrf_delay_us(100);
	  // Initial display
	#if defined SH1106_128_32
	// Init sequence for 128x32 OLED module
	SH1106writeCommand(SH1106_DISPLAYOFF);                    // 0xAE
	SH1106writeCommand(SH1106_SETDISPLAYCLOCKDIV);            // 0xD5
	SH1106writeCommand(0x80);                                 // the suggested ratio 0x80
	SH1106writeCommand(SH1106_SETMULTIPLEX);                  // 0xA8
	SH1106writeCommand(0x1F);
	SH1106writeCommand(SH1106_SETDISPLAYOFFSET);              // 0xD3
	SH1106writeCommand(0x0);                                  // no offset
	SH1106writeCommand(SH1106_SETSTARTLINE | 0x0);            // line #0 
	SH1106writeCommand(SH1106_CHARGEPUMP);                    // 0x8D
	if (vccState == SH1106_EXTERNALVCC) 
	  { SH1106writeCommand(0x10); }
	else 
	  { SH1106writeCommand(0x14); }
	SH1106writeCommand(SH1106_MEMORYMODE);                    // 0x20
	SH1106writeCommand(0x00);                                 // 0x0 act like ks0108
	SH1106writeCommand(SH1106_SEGREMAP | 0x1);
	SH1106writeCommand(SH1106_COMSCANDEC);
	SH1106writeCommand(SH1106_SETCOMPINS);                    // 0xDA
	SH1106writeCommand(0x02);
	SH1106writeCommand(SH1106_SETCONTRAST);                   // 0x81
	SH1106writeCommand(0x8F);
	SH1106writeCommand(SH1106_SETPRECHARGE);                  // 0xd9
	if (vccState == SH1106_EXTERNALVCC) 
	  { SH1106writeCommand(0x22); }
	else 
	  { SH1106writeCommand(0xF1); }
	SH1106writeCommand(SH1106_SETVCOMDETECT);                 // 0xDB
	SH1106writeCommand(0x40);
	SH1106writeCommand(SH1106_DISPLAYALLON_RESUME);           // 0xA4
	SH1106writeCommand(SH1106_NORMALDISPLAY);                 // 0xA6
	#endif

	#if defined SH1106_128_64
	// Init sequence for 128x64 OLED module
	SH1106writeCommand(SH1106_DISPLAYOFF);                    // 0xAE
	SH1106writeCommand(SH1106_SETDISPLAYCLOCKDIV);            // 0xD5
	SH1106writeCommand(0x80);                                 // the suggested ratio 0x80
	SH1106writeCommand(SH1106_SETMULTIPLEX);                  // 0xA8
	SH1106writeCommand(0x3F);
	SH1106writeCommand(SH1106_SETDISPLAYOFFSET);              // 0xD3
	SH1106writeCommand(0x00);                                 // no offset
	  
	SH1106writeCommand(SH1106_SETSTARTLINE | 0x0);            // line #0 0x40
	SH1106writeCommand(SH1106_CHARGEPUMP);                    // 0x8D
	if (vccState == SH1106_EXTERNALVCC) 
	  { SH1106writeCommand(0x10); }
	else 
	  { SH1106writeCommand(0x14); }
	SH1106writeCommand(SH1106_MEMORYMODE);                    // 0x20
	SH1106writeCommand(0x00);                                 // 0x0 act like ks0108
	SH1106writeCommand(SH1106_SEGREMAP | 0x1);
	SH1106writeCommand(SH1106_COMSCANDEC);
	SH1106writeCommand(SH1106_SETCOMPINS);                    // 0xDA
	SH1106writeCommand(0x12);
	SH1106writeCommand(SH1106_SETCONTRAST);                   // 0x81
	if (vccState == SH1106_EXTERNALVCC) 
	  { SH1106writeCommand(0x9F); }
	else 
	  { SH1106writeCommand(0xCF); }
	SH1106writeCommand(SH1106_SETPRECHARGE);                  // 0xd9
	if (vccState == SH1106_EXTERNALVCC) 
	  { SH1106writeCommand(0x22); }
	else 
	  { SH1106writeCommand(0xF1); }
	SH1106writeCommand(SH1106_SETVCOMDETECT);                 // 0xDB
	SH1106writeCommand(0x40);
	SH1106writeCommand(SH1106_DISPLAYALLON_RESUME);           // 0xA4
	SH1106writeCommand(SH1106_NORMALDISPLAY);                 // 0xA6
	#endif

	#if defined SH1106_96_16
	// Init sequence for 96x16 OLED module
	SH1106writeCommand(SH1106_DISPLAYOFF);                    // 0xAE
	SH1106writeCommand(SH1106_SETDISPLAYCLOCKDIV);            // 0xD5
	SH1106writeCommand(0x80);                                 // the suggested ratio 0x80
	SH1106writeCommand(SH1106_SETMULTIPLEX);                  // 0xA8
	SH1106writeCommand(0x0F);
	SH1106writeCommand(SH1106_SETDISPLAYOFFSET);              // 0xD3
	SH1106writeCommand(0x00);                                 // no offset
	SH1106writeCommand(SH1106_SETSTARTLINE | 0x0);            // line #0
	SH1106writeCommand(SH1106_CHARGEPUMP);                    // 0x8D
	if (vccState == SH1106_EXTERNALVCC) 
	  { SH1106writeCommand(0x10); }
	else 
	  { SH1106writeCommand(0x14); }
	SH1106writeCommand(SH1106_MEMORYMODE);                    // 0x20
	SH1106writeCommand(0x00);                                 // 0x0 act like ks0108
	SH1106writeCommand(SH1106_SEGREMAP | 0x1);
	SH1106writeCommand(SH1106_COMSCANDEC);
	SH1106writeCommand(SH1106_SETCOMPINS);                    // 0xDA
	SH1106writeCommand(0x2);	//ada x12
	SH1106writeCommand(SH1106_SETCONTRAST);                   // 0x81
	if (vccState == SH1106_EXTERNALVCC) 
	  { SH1106writeCommand(0x10); }
	else 
	  { SH1106writeCommand(0xAF); }
	SH1106writeCommand(SH1106_SETPRECHARGE);                  // 0xd9
	if (vccState == SH1106_EXTERNALVCC) 
	  { SH1106writeCommand(0x22); }
	else 
	  { SH1106writeCommand(0xF1); }
	SH1106writeCommand(SH1106_SETVCOMDETECT);                 // 0xDB
	SH1106writeCommand(0x40);
	SH1106writeCommand(SH1106_DISPLAYALLON_RESUME);           // 0xA4
	SH1106writeCommand(SH1106_NORMALDISPLAY);                 // 0xA6
	#endif

	SH1106writeCommand(SH1106_DISPLAYON);                       //--turn on oled panel
	  
	display();
    while (1)
    {
        // Reset rx buffer and transfer done flag
//		memset(m_rx_buf, 0, m_length);
//		spi_xfer_done = false;

//		APP_ERROR_CHECK(nrf_drv_spi_transfer(&spi, m_tx_buf, m_length, m_rx_buf, m_length));

//		while (!spi_xfer_done)
//		{
//			__WFE();
//		}
//		
		NRF_LOG_FLUSH();

//		bsp_board_led_invert(BSP_BOARD_LED_0);
//		nrf_delay_ms(200);
    }
}
